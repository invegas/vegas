<!DOCTYPE html>
<html>
<head>
	<title>你真的了解setTimeout和setInterval吗？</title>
	<link rel="stylesheet" type="text/css" href="css/bootstrap.css">
	<link rel="stylesheet" type="text/css" href="prettify/sunburst.css">
	<script type="text/javascript" src="prettify/prettify.js"></script>	
	<style type="text/css">
		body {
			font-family: '微软雅黑';
		}
		blockquote p{
			font-style: italic;
			font-size: 12px;
		}
	</style>
</head>
<body onload="prettyPrint()">
	<div class="container">
		<div class="row">
			<div class="span1"></div>
			<div class="span6">
				<h3>你真的了解setTimeout和setInterval吗？</h3>
			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>		
		<div class="row">
			<div class="span1"></div>
			<div class="span6">
				<p>setTimeout和setInterval的基本用法我们不谈，无非是1.指定延迟后调用函数，2.以指定周期调用函数</p>
				<p>让我们想象一个意外情况，比如说下面的setInterval</p>
<pre class="prettyprint lang-javascript">
setInterval(function () {
	func(i++);
}, 100)
</pre>
				<p>我们以每100毫秒调用一次func函数，如果func的执行时间少于100毫秒的话好办，在遇到下一个100毫秒前就能够执行完：</p>
				<img src="http://javascript.info/files/tutorial/advanced/timing/interval1.png">
				<p>但如果func的执行时间大于100毫秒，该触发下一个func函数时之前的还没有执行完怎么办？（前提是你要知道javascript只有单线程，不存在同时执行致命一说，才会有这个问题）。答案如下图所示，那么第二个func会在队列（这里的队列是指event loop，在下文中会详细提到）中等待，直到第一个函数执行完</p>
				<img src="http://javascript.info/files/tutorial/advanced/timing/interval3.png">
				<p>如果第一个函数的执行时间特别长，在执行的过程中本应触发了许多个func怎么办，那么所有这些应该触发的函数都会进入队列吗？</p>
				<p><strong>不，只要发现队列中有一个被执行的函数存在，那么其他的统统忽略。</strong>如下图，在第300毫秒和400毫秒处的回调都被抛弃，一旦第一个函数执行完后，接着执行队列中的第二个，即使这个函数已经“过时”很久了。</p>
				<img src="http://javascript.info/files/tutorial/advanced/timing/interval4.png">
				<p>还有一点，虽然你在setInterval的里指定的周期是100毫秒，<strong>但它并不能保证两个函数之间调用的间隔一定是一百毫秒。</strong>在上面的情况中，如果队列中的第二个函数时在第450毫秒处结束的话，在第500毫秒时，它会继续执行下一轮func，也就是说这之间的间隔只有50毫秒，而非周期100毫秒</p>
				<p>那如果我想保证每次执行的间隔应该怎么办？用setTimeout，比如下面的代码：</p>
<pre class="prettyprint lang-javascript">
  var i = 1
  var timer = setTimeout(function() { 
    alert(i++) 
    timer = setTimeout(arguments.callee, 2000)
  }, 2000)
</pre>
				<p>上面的函数每2秒钟递归调用自己一次，你可以在某一次alert的时候等待任意长的时间（不按“确定”按钮），接下来无论你什么时候点击“确定”， 下一次执行一定离这次确定相差2秒钟的</p>
				<p>下面上下两段代码虽然看上去功能一致，但实际并非如此，原因就是我上面所说</p>
<pre class="prettyprint lang-javascript">
setTimeout(function repeatMe() {     
  /* Some long block of code... */   
  setTimeout(repeatMe, 10);          
}, 10);                              
setInterval(function() {             
  /* Some long block of code... */   
}, 10);                              
</pre>
				<p><strong>setTimeout除了做定时器外还能干什么用？</strong></p>
				<p>非常多，比如说：在处理DOM点击事件的时候通常会产生冒泡，正常情况下首先触发的是子元素的handler，再触发父元素的handler，如果我想让父元素的handler先于子元素的handler执行应该怎么办？那就用setTimeout延迟子元素handler若干个毫秒执行吧。问题是这个“若干个”毫秒应该是多少？<strong>可以是0</strong></p>
				<p>你可能会疑惑如果是0的话那不是立即执行了吗？不，看下面一道题目</p>
<pre class="prettyprint lang-javascript">
(function () {
	setTimeout(function () {
		alert(2);
	}, 0);

	alert(1);
})()                          
</pre>
				<p>先弹出的应该是1，而不是你以为“立即执行”的2。</p>
			






			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>
	</div>
	<script type="text/javascript" src="js/bootstrap.js"></script>
</body>
</html>