<!DOCTYPE html>
<html>
<head>
    <title>你真的了解setTimeout和setInterval吗？</title>
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="prettify/sunburst.css">
    <script type="text/javascript" src="prettify/prettify.js"></script> 
    <style type="text/css">
        body {
            font-family: '微软雅黑';
        }
        blockquote p{
            font-style: italic;
            font-size: 12px;
        }
    </style>
</head>
<body onload="prettyPrint()">
    <div class="container">
        <div class="row">
            <div class="span1"></div>
            <div class="span6">
                <h3>你真的了解setTimeout和setInterval吗？</h3>
            </div>
            <div class="span4"></div>
            <div class="span1"></div>
        </div>      
        <div class="row">
            <div class="span1"></div>
            <div class="span6">
                <p>setTimeout和setInterval的基本用法我们不谈，无非是1.指定延迟后调用函数，2.以指定周期调用函数</p>
                <p>让我们想象一个意外情况，比如说下面的setInterval</p>
<pre class="prettyprint lang-javascript">
setInterval(function () {
    func(i++);
}, 100)
</pre>
                <p>我们以每100毫秒调用一次func函数，如果func的执行时间少于100毫秒的话好办，在遇到下一个100毫秒前就能够执行完：</p>
                <img src="http://javascript.info/files/tutorial/advanced/timing/interval1.png">
                <p>但如果func的执行时间大于100毫秒，该触发下一个func函数时之前的还没有执行完怎么办？（前提是你要知道javascript只有单线程，不存在同时执行致命一说，才会有这个问题）。答案如下图所示，那么第二个func会在队列（这里的队列是指event loop，在下文中会详细提到）中等待，直到第一个函数执行完</p>
                <img src="http://javascript.info/files/tutorial/advanced/timing/interval3.png">
                <p>如果第一个函数的执行时间特别长，在执行的过程中本应触发了许多个func怎么办，那么所有这些应该触发的函数都会进入队列吗？</p>
                <p><strong>不，只要发现队列中有一个被执行的函数存在，那么其他的统统忽略。</strong>如下图，在第300毫秒和400毫秒处的回调都被抛弃，一旦第一个函数执行完后，接着执行队列中的第二个，即使这个函数已经“过时”很久了。</p>
                <img src="http://javascript.info/files/tutorial/advanced/timing/interval4.png">
                <p>还有一点，虽然你在setInterval的里指定的周期是100毫秒，<strong>但它并不能保证两个函数之间调用的间隔一定是一百毫秒。</strong>在上面的情况中，如果队列中的第二个函数时在第450毫秒处结束的话，在第500毫秒时，它会继续执行下一轮func，也就是说这之间的间隔只有50毫秒，而非周期100毫秒</p>
                <p>那如果我想保证每次执行的间隔应该怎么办？用setTimeout，比如下面的代码：</p>
<pre class="prettyprint lang-javascript">
  var i = 1
  var timer = setTimeout(function() { 
    alert(i++) 
    timer = setTimeout(arguments.callee, 2000)
  }, 2000)
</pre>
                <p>上面的函数每2秒钟递归调用自己一次，你可以在某一次alert的时候等待任意长的时间（不按“确定”按钮），接下来无论你什么时候点击“确定”， 下一次执行一定离这次确定相差2秒钟的</p>
                <p>下面上下两段代码虽然看上去功能一致，但实际并非如此，原因就是我上面所说</p>
<pre class="prettyprint lang-javascript">
setTimeout(function repeatMe() {     
  /* Some long block of code... */   
  setTimeout(repeatMe, 10);          
}, 10);                              
setInterval(function() {             
  /* Some long block of code... */   
}, 10);                              
</pre>
                <p><strong>setTimeout除了做定时器外还能干什么用？</strong></p>
                <p>非常多，比如说：在处理DOM点击事件的时候通常会产生冒泡，正常情况下首先触发的是子元素的handler，再触发父元素的handler，如果我想让父元素的handler先于子元素的handler执行应该怎么办？那就用setTimeout延迟子元素handler若干个毫秒执行吧。问题是这个“若干个”毫秒应该是多少？<strong>可以是0</strong></p>
                <p>你可能会疑惑如果是0的话那不是立即执行了吗？不，看下面一道题目</p>
<pre class="prettyprint lang-javascript">
(function () {
    setTimeout(function () {
        alert(2);
    }, 0);

    alert(1);
})()                          
</pre>
                <p>先弹出的应该是1，而不是你以为“立即执行”的2。</p>
                <p>setTimeout，setInterval都存在一个最小延迟的问题，虽然你给的delay值为0，但是浏览器执行的是自己的最小值。HTML5标准是4ms，但并不意味着所有浏览器都会遵循这个标准，包括手机浏览器在内，这个最小值既有可能小于4ms也有可能大于4ms。在标准中，如果在setTimeout中嵌套一个setTimeout, 那么嵌套的setTimeout的最小延迟为10ms。</p>
                <p><strong>下面我们聊聊setTimeou和线程的一些关系</strong></p>
                <p>现在我有一个非常耗时的操作（如下面的代码，在table中插入2000行），我想计算这个操作所耗的时间应该怎么办？你觉得下面这个用<code>new Date</code>来计算的方法怎么样：</p>
<pre class="prettyprint lang-javascript">
var t1 = +new Date();

var tbody = document.getElementsByTagName("tbody")[0];
for (var i = 0; i < 20000; i++) {
    var tr = document.createElement("tr");
    for (var t = 0; t < 6; t++) {
        var td = document.createElement("td");
        td.appendChild(document.createTextNode(i + "," + t));
        tr.appendChild(td);
    }
    tbody.appendChild(tr);
}

var t2 = +new Date();
console.log(t2 - t1);                         
</pre>
                <p>如果你尝试运行起来就会发现问题，在这2000行还没有渲染出来的时候，控制台就已经打印出来了时间，这两个时间差并非误差所致（可能这个操作需要5秒，甚至10秒以上），但是打印出来的时间只有1秒左右，这是为什么？</p>
                <p>因为Javascript是单线程的(这里不谈web worker),也就是说浏览器无论什么时候都只有一个JS线程在运行JS程序。或许是因为单线程的缘故，也同时因为大部分触发的事件是异步的，JS采用一种队列(event loop)的机制来处理各个事件，比如用户的点击，ajax异步请求,所有的事件都被放入一个队列中，然后先进先出，逐个执行。这也就解释了开头setInterval的那种情况。</p>
                <p>另一方面，浏览器还有一个GUI渲染线程，当需要重绘页面时渲染页面。但问题是GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
                <p><strong>所以,在脚本中执行对界面进行更新操作,如添加结点,删除结点或改变结点的外观等更新并不会立即体现出来,这些操作将保存在一个队列中,待JavaScript引擎空闲时才有机会渲染出来.</strong></p>
                <p>所以，上面的那个例子中算出的时间只是javascript执行的时间，在这之后，GUI线程才开始渲染，而此时计时已经结束了。那么如何你能计算出正确时间呢？在结尾添加一个setTimeout</p>
<pre class="prettyprint lang-javascript">
var t1 = +new Date();

var tbody = document.getElementsByTagName("tbody")[0];
for (var i = 0; i < 20000; i++) {
    var tr = document.createElement("tr");
    for (var t = 0; t < 6; t++) {
        var td = document.createElement("td");
        td.appendChild(document.createTextNode(i + "," + t));
        tr.appendChild(td);
    }
    tbody.appendChild(tr);
}

setTimeout(function () {
    var t2 = +new Date();
    console.log(t2 - t1);   
}, 0)
</pre>              
            <p>这样能让操纵DOM的代码执行完后不至于立即执行<code>t2 - t1</code>，而在中间空隙的时间恰好允许浏览器执行GUI线程。渲染完之后，才计算出时间。</p>
            <p>下面这个例子也是同样的道理，可以如何改进才能看到颜色的改变呢?留作作业吧:</p>
<pre class="prettyprint lang-javascript">
function run() {
  var div = document.getElementsByTagName('div')[0]
  for(var i=0xA00000;i < 0xFFFFFF;i++) {
    div.style.backgroundColor = '#'+i.toString(16)
  }
}
</pre>              
            <p><strong>setInterval有一个很重要的应用是javascript中的动画</strong>。这种情况下通常会有多个计时器同时运行，如果同时大量计时器同时运行的话，会引起一些个问题，比如如何回收这些计时器？jquery的作者John Resig建议建立一个管理中心，它给出的一个非常简单的代码如下：</p>
<pre class="prettyprint lang-javascript">
var timers = {                               
  timerID: 0,                                           
  timers: [],                                           
  add: function(fn) {                            
    this.timers.push(fn);
  },
  start: function() {                             
    if (this.timerID) return;
    (function runNext() {
      if (timers.timers.length > 0) {
        for (var i = 0; i < timers.timers.length; i++) {
          if (timers.timers[i]() === false) {
            timers.timers.splice(i,1);
            i--;
          }
        }
        timers.timerID = setTimeout(runNext, 0);
      }
    })();
  },
  stop: function() {                                  
    clearTimeout(this.timerID);
    this.timerID = 0;
  }
};
</pre>                  
            <p>注意看中间的start方法：他把所有的定时器都存在一个<code>timers</code>队列（数组）中，只要队列长度不为0，就轮询执行队列中的每一个子计时器，如果某个子计时器执行完毕（这里的标志是返回值是false），那就把这个计时器踢出队列。继续轮询后面的计时器。</p>
            <p>上面描述的整个一轮轮询就是<code>runNext</code>，并且递归轮询，一遍一遍的执行下去<code>timers.timerID = setTimeout(runNext, 0)</code>直到数组为空。</p>
            <p>注意到上面没有使用到stop方法，jquery的动画animate就是使用的是这种机制，不过更完善复杂，摘一段jquery源码看看，比如就类似的runNext这段:</p>
<pre class="prettyprint lang-javascript">
// /src/effects.js:674
jQuery.fx.tick = function() {
    var timer,
        timers = jQuery.timers,
        i = 0;

    fxNow = jQuery.now();

    for ( ; i < timers.length; i++ ) {
        timer = timers[ i ];
        // Checks the timer has not already been removed
        if ( !timer() && timers[ i ] === timer ) {
            timers.splice( i--, 1 );
        }
    }

    if ( !timers.length ) {
        jQuery.fx.stop();
    }
    fxNow = undefined;
};

// /src/effects.js:703
jQuery.fx.start = function() {
    if ( !timerId ) {
        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
    }
};
</pre>                              
            <p>不解释，和上面的那段已经非常类似了，有兴趣的同学可以阅读整段effect.js代码。</p>




            </div>
            <div class="span4"></div>
            <div class="span1"></div>
        </div>
    </div>
    <script type="text/javascript" src="js/bootstrap.js"></script>
</body>
</html>