<!DOCTYPE html>
<html>
<head>
	<title>谈javascript变量声明</title>
	<link rel="stylesheet" type="text/css" href="css/bootstrap.css">
	<link rel="stylesheet" type="text/css" href="prettify/sunburst.css">
	<script type="text/javascript" src="prettify/prettify.js"></script>	
	<style type="text/css">
		body {
			font-family: '微软雅黑';
		}
		blockquote p{
			font-style: italic;
			font-size: 12px;
		}
	</style>
</head>
<body onload="prettyPrint()">
	<div class="container">
		<div class="row">
			<div class="span1"></div>
			<div class="span6">
				<h3>答寒冬的面试题</h3>
			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>		
		<div class="row">
			<div class="span1"></div>
			<div class="span6">




				<p>有关注前端和微博的朋友一定留意到了前一阵寒冬和玉伯关于前端面试的讨论，后来老赵和左耳朵耗子也加入其中，讨论带来了非常多的启发和思考——不久之前自己也经历了几轮面试，决心对自己的基础开始加强，正巧寒冬老师题目由浅入深，非常有代表性，有些概念自己也模糊，决心花时间把这些概念全部弄清楚，梳理一遍</p>
				<p>寒冬的微博原文如下</p>
				<blockquote>
  					<p>面试的时候问个css的position属性能刷掉一半的人这是啥情况……其实这问题我本来打算的是可以顺着一路扯到normal flow、containing block、bfc、margin collapse，base line，writing mode，bidi，这样一路问下去的，奈何第一个问题（亲我真的只问了position有哪些取值和行为啊）就悲剧了……</p>
				</blockquote>
				<p>并且后来寒冬后来也就这一事件写了两篇文章(<a target="_blank" href="https://github.com/wintercn/blog/issues/4">《谈谈面试与面试题》</a>， <a target="_blank" href="https://github.com/wintercn/blog/issues/5">《阿里巴巴无线前端团队》</a>)来做了一些说明，我们就根据这些材料对知识点进行一些梳理。本文将谈到:</p>
				<ul>
					<li>position</li>
					<li>normal flow</li>
					<li>containing block</li>
					<li>bfc</li>
					<li>margin collapse</li>
					<li>writing mode</li>
					<li>bidi</li>
					<li>以及各种综合和边缘情况</li>
				</ul>
				<p>最困难的是当你在谈一个概念的同时不得不对其他概念有所涉及——但其实所有的概念和方案都是为了解决问题而生，我打算从最简单的布局开始，以解决复杂的布局方案为线索，逐渐引入这些概念。本文的资料来源于国外国内的通俗博客和实战经验，如果直接引用w3c的概念我感觉会有一些晦涩（重要的是我看的也很头大），但仍然会做引用。本文只是抛砖引玉，如果有不正确的地方请多多指正。</p>
				<br>
				<h3>Normal Flow</h3>
				<p>我倾向把normal flow翻译为标准流。当你在一个空白的网页上插入不同的标签div, p, span等，那么这些标签形成的元素将以何种标准进行排列？那就是标准流。</p>
				<p>谈论标准流的前提是，页面上的所有元素都没有有关布局的css(float,display,position等)进行修饰，也就是说所有的元素要么是块状元素(block)，要么是行内元素(inline)</p>
				<p>块状元素将在页面上或者包含他们的包含块(containing block)中，从左上方开始，并且是从垂直自上往下进行填充，不用担心横向，因为块级元素非常霸道，一个元素必定占一整行，即使你给它指定宽度，它所在的那一行余下的宽度也是属于它的，不会有后面的元素进来，即使后面的元素很窄能刚好插进来。而上下两个块之间的距离则根据他们的外边距和外边距的折叠规则(margin collapse)而定，这个后面会谈到。比如看下面这个例子</p>
<pre class="prettyprint lang-css">
div { border: 1px solid black; }
div div { height: 100px; }
.a { margin: 20px 0; }
.b { margin: 30px 0; width: 100px; }
.c { margin: -50px 0 0; }
</pre>	
<pre class="prettyprint lang-html">
&lt;div&gt;
    &lt;div class="a"&gt;&lt;/div&gt;
    &lt;div class="b"&gt;&lt;/div&gt;
    &lt;div class="c"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
<div style="border: 1px solid black;">
	<div style="border: 1px solid black; height: 50px; margin: 10px 0;"></div>
	<div style="border: 1px solid black; height: 50px; margin: 20px 0; width: 100px;"></div>
	<div style="border: 1px solid black; height: 50px; margin: -30px 0 0;"></div>
</div>
				<p>而行内元素顾名思义，则优先进行横向排列，从容器的左上开始，后面的元素一个紧挨一个的排列在这一行中，只有当位置不够了，才会被挤到下一行去，</p>
<pre class="prettyprint lang-css">
div { width: 100px; border: 1px solid black;}
span.a {background: yellow;}
span.b {background: red;}
span.c {background: blue;}
</pre>	
<pre class="prettyprint lang-html">
&lt;div&gt;
&lt;span class="a" &gt;This is an span element&lt;/span&gt;
&lt;span class="b" &gt;This is another span&lt;/span&gt;
&lt;span class="c" &gt;This is   the third span&lt;/span&gt;    
&lt;/div&gt;
</pre>
<div style="width: 100px; border: 1px solid black;">
	<span style="background: yellow;">This is an span element</span>
	<span style="background: red;">This is another span</span>
	<span style="background: blue;">This is   the third span</span>    
</div>
				<p>在标准流的状态下，如果两种元素混合在一起，那么将各自遵循各自的标准，理论上是不会有干扰的。临时想到一个问题，如果块状和行内上下相邻，并且都配备有外边距，那么外边距怎么计算？再复杂一点，行内元素所在的那一行有好几个行内元素，并且每个的外边距都不相同，那么与垂直相邻的块状元素的距离怎么算？代码如下</p>
<pre class="prettyprint lang-css">
div { width: 100px; border: 1px solid black; margin: 20px;}
span.a {margin: 10px 0 0;}
span.b {margin: 20px 0 0;}
span.c {margin: 30px 0 0;}
</pre>	
<pre class="prettyprint lang-html">
&lt;div class="block"&gt;&lt;/div&gt;
&lt;span class="a"&gt;This is a span&lt;/span&gt;
&lt;span class="b"&gt;This is b span&lt;/span&gt;
&lt;span class="c"&gt;This is c span&lt;/span&gt;
</pre>
				<p>这个问题还涉及另一个概念：盒子模型，如果又要展开又大了去了。在这里只说一点，<strong>行内元素的margin和padding只对它的左右元素有影响，对上下无影响</strong>，具体看下面代码</p>
<pre class="prettyprint lang-css">
.p { width: 200px; height: 50px; border: 1px solid black;}
.span {margin: 20px;}
</pre>	
<pre class="prettyprint lang-html">
&lt;p&gt;
&lt;span&gt;this is span&lt;/span&gt;&lt;span class="span"&gt;this is span&lt;/span&gt;&lt;span&gt;this is span&lt;/span&gt;&lt;span&gt;this is span&lt;/span&gt;&lt;span&gt;this is span&lt;/span&gt;
&lt;/p&gt;
</pre>
				<p style="width: 200px; height: 50px; border: 1px solid black;">
						<span>this is span </span><span style="margin: 20px; display:inline;">this is span </span><span>this is span </span><span>this is span </span><span>this is span </span>				
				</p>
				<p>本节主要参考资料：</p>
				<ul>
					<li><a target="_blank" href="http://www.maxdesign.com.au/articles/inline/">Inline elements and padding</a></li>
					<li><a target="_blank"href="http://www.w3.org/TR/CSS2/visuren.html#normal-flow">W3C: Normal flow</a></li>
					<li><a target="_blank" href="http://webdesign.about.com/od/cssglossary/g/bldefnormalflow.htm">Webdesign:normal flow</a></li>
					<li><a target="_blank" href="http://css.maxdesign.com.au/floatutorial/definitions.htm">Some definitions:Normal flow</a></li>
				</ul>
				<h3>BFC(Block Formatting Context)</h3>
				<p>好吧，必须承认我也是第一接触BFC的概念，很惭愧，于是疯狂的查找资料，对它概念的介绍引用阿里巴巴用户体验部的<a target="_blank" href="http://www.aliued.cn/2012/12/31/css%E5%B8%83%E5%B1%80%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8bfc%E7%9A%84%E4%BE%8B%E5%AD%90.html">一篇文章</a>的一段话</p>
				<blockquote>
					<p>什么是BFC(Block Formatting Context)，简单讲，它是提供了一个独立布局的环境，每个BFC都遵守同一套布局规则。例如，在同一个BFC内，盒子会一个挨着一个的排，相邻盒子的间距是由margin决定且垂直方向的margin会重叠。而float和clear float也只对同一个BFC内的元素有效。</p>
				</blockquote>
				<p>在提BFC的同时也不得不提另一个概念，IE的haslayout属性，一旦元素的这两个属性（haslayout在IE下）被触发，他们都能给自己提供一个独立的布局环境（我的疑问在于不独立的布局环境又是什么情况？）。当元素的CSS属性设置了下列之一时，即可创建一个BFC:</p>
				<p>那么如何触发BFC，继续引用一淘的文章:</p>
				<blockquote>
					<p>非块级盒子的浮动元素、绝对定位元素及块级容器(比如inline-blocks，table-cells和table-captions)，以及overflow属性是visible之外任意值的块级盒子，都会创建了一个BFC。即当元素CSS属性设置了下列之一时，即可创建一个BFC:</p>
					<ul>
						<li>float：left | right</li>
						<li>position：absolute | fixed</li>
						<li>display: table-cell | table-caption | inline-block	</li>
						<li>display: table-cell | table-caption | inline-block</li>
					</ul>
				</blockquote>
				<p>然后这个独立布局的规则是这样的(<a target="_blank" href="http://www.smallni.com/haslayout-block-formatting-contexts/">摘自</a>)</p>
				<blockquote>
					<ul>
						<li>在创建了 BFC的元素中，其子元素会一个接一个地放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻的元素之间的垂直距离取决于 ‘margin’ 特性。在BFC中相邻的块级元素的垂直边距会折叠（collapse）。</li>
						<li>在BFC 中，每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）， 即使存在浮动也是如此（尽管一个元素的内容区域会由于浮动而压缩），除非这个元素也创建了一个新的BFC。</li>
					</ul>
				</blockquote>
				<p>上面的定义是翻译自W3C的标准。因为自己经验有限，在这里我直接举出我找到的的BFC的经典用处，希望大家能从中体会。</p>
				<p>在所有的文章中，被列举最频繁的例子莫过于<strong>阻止文字围绕浮动元素</strong>，请看下面代码</p>
<pre class="prettyprint lang-css">
.item {width: 200px; height: 150px; border: 1px solid black;}
.pic{width:80px;height:80px;margin:10px;background-color:#acdae5;float:left;}
</pre>	
<pre class="prettyprint lang-html">
&lt;div class="item"&gt;
	&lt;div class="pic">picture&lt;/div&gt;
	&lt;p class="text"&gt;
	测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
	&lt;/p&gt;
&lt;/div&gt;
</pre>
<div class="item" style="width: 200px; height: 150px; border: 1px solid black;">
    <div class="pic" style="width:80px;height:80px;margin:10px;background-color:#acdae5;float:left;">picture</div>
    <p class=”text”>
    	测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
    </p>
</div>		
				<p>此时我们要做一个重要的决定！就是阻止文字围绕左侧的浮动块——那就开启右侧文字的BFC属性,用overflow:hidden</p>		
<pre class="prettyprint lang-css">
.item {width: 200px; height: 150px; border: 1px solid black;}
.pic{width:80px;height:80px;margin:10px;background-color:#acdae5;float:left;}
.text {overflow: hidden;}
</pre>	
<div class="item" style="width: 200px; height: 150px; border: 1px solid black;">
    <div class="pic" style="width:80px;height:80px;margin:10px;background-color:#acdae5;float:left;">picture</div>
    <p class=”text” style="overflow:hidden;">
    	测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试
    </p>
</div>		
				<p><strong>用法二：创建了 BFC的元素中，浮动元素参与高度的计算</strong>，这个方法也可以用于消除因为子元素浮动引起的折叠</p>
<pre class="prettyprint lang-css">
.header {border: 1px solid black;}
.logo {width: 50px; height: 50px; background: blue; float: left;}
</pre>	
<pre class="prettyprint lang-html">
&lt;div class="header"&gt;
   &lt;div class="logo"&gt;&lt;/div&gt;
&lt;/div>
</pre>
<div style="border: 1px solid black;">
	<div style="width: 50px; height: 50px; background: blue; float: left;"></div>
</div>
				<div class="clearfix"></div>
				<p>这是一个很常见的问题，在网站有一个标题区域header，其中有一个logo，并且设置logo向左浮动。但问题是一旦logo向左浮动，它的包含块因为float的一些特性（后面介绍），自动折叠了起来</p>
				<p>那么就设置包含块的BFC的属性吧，照上面可以使用overflow属性</p>
<pre class="prettyprint lang-css">
.header {border: 1px solid black; overflow:hidden;}
</pre>					
<div style="border: 1px solid black;overflow: hidden;">
	<div style="width: 50px; height: 50px; background: blue; float: left;"></div>
</div>
				<p>于是成功了，并且此时当计算header的高度时，将把子元素的float元素的高度计算进来。其实解决这一类的问题应该算是<strong>清除浮动</strong>。这一类解决方案已经非常成熟了，并且一个好的方案知识点的信息量还是比较大的，可以好好介绍一下。</p>
				<p><strong>用处三：创建了 BFC的元素不会与它们的子元素发生外边距折叠</strong></p>
				<p>外边距折叠规则中有一条是，当赤裸裸的子元素（没有padding，border）与赤裸裸的父元素（还是没有padding，border）进行接触时，他们的外边距会按一定的规则进行折叠。比如</p>
<pre class="prettyprint lang-css">
div {margin:30px 0; background: yellow;}
p {margin: 20px 0; background: blue;}
</pre>	
<pre class="prettyprint lang-html">
&lt;div&gt;
   &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</pre>
<div style="margin:30px 0; background: yellow;">
	<p style="margin: 20px 0;background: blue;">This is text</p>
</div>				
				<p>看到上面因为父元素与子元素的外边距发生了折叠，父元素已经完全和子元素重合。如果元素是赤裸裸但又不想和父元素发生外边距折叠怎么办，那就给父元素设置BFC!</p>
<pre class="prettyprint lang-css">
div {margin:30px 0; background: yellow; overflow: hidden;}
</pre>
<div style="margin:30px 0; background: yellow; overflow: hidden;">
	<p style="margin: 20px 0; background: blue;">This is text</p>
</div>			
				<p>以上是三个基本用处的介绍，至少我个人对BFC还不是很理解，比如拥有不同布局的元素究竟应该如何在BFC的元素中排列等。希望有经验的同学指点一下。</p>
				<p>参考文章</p>
				<ul>
					<li><a href="http://www.aliued.cn/2012/12/31/css%E5%B8%83%E5%B1%80%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8bfc%E7%9A%84%E4%BE%8B%E5%AD%90.html" target="_blank">CSS布局中一个简单的应用BFC的例子</a></li>
					<li><a href="http://www.smallni.com/haslayout-block-formatting-contexts/" target="_blank">hasLayout && Block Formatting Contexts</a></li>
					<li><a href="http://www.w3ctech.com/p/1101" target="_blank">更加直观地了解hasLayout和BFC</a></li>
					<li><a href="http://stackoverflow.com/questions/6196725/how-does-the-css-block-formatting-context-work" target="_blank">How does the CSS Block Formatting Context work?</a></li>
				</ul>
				<p>上面的文章几乎都拿BFC与haslayout属性进行对比，上面的第二篇把异同之处都整理了出来。如果是页面布局方向的同学可以深入阅读。</p>
				<h3>Position: relative</h3>
				<p>Position有四种可选值，static，relative，absolute，fixed。当你不对元素做任何position属性时，默认即为static，<strong>注意此时你无法对元素的z-index值进行设置</strong>，只有当你把position设置为出static以外的值时，z-index才生效。所以最保险的作法是设置相对定位。</p>
				<p>CSS2.1中元素是根据三种的位置方案(positioning modes or schemes)被布局的，分别是标准流(normal flow), 浮动(float)和绝对定位(absolute position)</p>
				<p>相对定位虽然被改动了position值，但是仍然遵循标准流的规则。CSS中难点之一在于，如何根据当前元素的位置属性判断出相邻，或者后代的位置属性，而判断出当前元素的位置属性并不难。</p>
				<p>你可以这么理解，相对定位的元素仍然处于标准流中，只要你没有设置偏移值(top, left, right, buttom)；如果你设置了偏移值，那么元素就会相对于你在标准流中的位置，依照值进行偏移。<strong>但你周围的元素会以为你还在标准流中</strong>，有一种灵魂出窍的感觉。见代码</p>
<pre class="prettyprint lang-css">
div { width: 200px; height: 40px; border: 1px solid black; position: relative; }
.a {background: yellow; }
.b {background: blue; }
</pre>	
<pre class="prettyprint lang-html">
&lt;div class="a"&gt;&lt;/div&gt;
&lt;div class="b"&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
</pre>
<div style="width: 200px; height: 40px; border: 1px solid black; position: relative;background: yellow;"></div>
<div style="width: 200px; height: 40px; border: 1px solid black; position: relative;background: blue;"></div>
<div style="width: 200px; height: 40px; border: 1px solid black;"></div>				
				<p>以上是正常情况，而下面将演示非正常情况，我将给前两个容器添加相偏移</p>
<pre class="prettyprint lang-css">
.a {background: yellow; top: 10px; left: 10px;}
.b {background: blue; top: 10px; left: 10px;}
</pre>	
<div style="width: 200px; height: 40px; border: 1px solid black; position: relative;background: yellow;top: 20px; left: 20px;"></div>
<div style="width: 200px; height: 40px; border: 1px solid black; position: relative;background: blue;top: 10px; left: 10px;"></div>
<div style="width: 200px; height: 40px; border: 1px solid black;"></div>				
				<p>注意到虽然前两个元素虽然发生了移动，但是第三个元素并没有收到影响，并且前两个元素的移动都是根据自己的相对位移。<strong>如果这三个盒子还存在外边距的话，那么外边距的折叠效果仍然是与标准流保持一致的。</strong></p>
				<p>再留意上面的一个细节，这三个容器我都没有设置z-index，你也可以通过firebug之类的工具查看到它们的z-index的确是auto；但却出现了有叠加的情况；</p>
				<p>留意一个边界情况，如果偏移量有矛盾怎么办，比如</p>
<pre class="prettyprint lang-css">
.a {
  left: 10px;
  right: 10px;
}
</pre>					
				<p><strong>记住这样一个原则，在矛盾的情况下left的优先级要比right高，top的优先级要比bottom高，即使right书写在left后面。</strong></p>
				<h3>Containing Block & Position: absolute</h3>





			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>
	</div>
	<script type="text/javascript" src="js/bootstrap.js"></script>
</body>
</html>