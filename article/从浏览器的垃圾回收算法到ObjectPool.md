


浏览器的脚本引擎有一个不足的地方是，你无法通过javascript语法强制让脚本引擎进行垃圾回收（Garbage Collection，在文中以GC代替）和内存释放。虽然你在脚本中执行 `delete someVariable` 或者 `someVariable = null` 又或者 `someVariable = void 0`。但事实上你做的都只是删除了变量对某个对象的引用而已，至于被删除引用的对象是否能够被回收，又何时能否被回收，这就只能由脚本引擎说得算了。

这会留下一个性能上的隐患，因为GC也是要消耗浏览器资源的。理想的状态应该是在浏览器进程空闲的时候进行GC，相反如果GC不巧发生在很多脚本需要处理的时候，这会给我们的程序火上浇油，让我们的程序显得慢和卡——那么流畅的标准又是什么？至少应该满足每秒60帧(如果你有PC游戏经验的话，30fps的画面感也是可以接受的)。换而言之，你必须在16.7ms之内执行完每一帧的所有脚本。

这篇文章主要分为两部分，一是浏览器的脚本引擎的垃圾回收算法，二是如何使用Object Pool解决GC引起性能问题。其实这两者并没有太大的关系，只是作为与浏览器垃圾回收相关的内容，可以一并拿到桌面上谈一谈。

## 脚本引擎的垃圾回收算法

### Reference Counting

早在Javascript 1.1版本和Netscape 3中（甚至在早期火狐中），一个对象是否被回收是由这个对象的被引用次数决定的。对象一旦被创建并被一个变量引用，那么它的引用次数便是1，如果该对象又被赋值给了另一个变量，那么引用便增为2.一旦某变量删除了对该对象的引用或者另被赋值，那么该对象的引用便又降为1.理论上来说，当一个对象的被引用次数降为0时，表示没有任何变量在引用该对象了，它已经毫无用处可以被回收从内存中释放了。

但是这个算法有一个缺陷，比如当存在如下图循环引用的情况时：

```
A<-------|     C----->X
|        |     D----->Y
|------->B     E----->Z
```

A与B互相引用，A和B的被引用次数都不为0，按照算法规则是不会被垃圾回收。但实际情况是A与B成了座“孤岛”，没有任何以外的变量引用他们。他们不会被回收，又不会再被发现和引用，这便造成了内存泄露。

举个实际的例子，已知的在IE6、7中，DOM对象的回收使用的就是Reference Counting算法，比如下面这个例子

```
var div = document.createElement("div");
div.onclick = function handler(){
  doSomething();
};
```

- div通过onclick属性对函数handler存在引用
- 函数对div也存在引用，因为在handler的作用域中可以访问到div

这样的循环会导致两个对象都没有办法被垃圾回收，引起内存泄露。

### Mark-and-Sweep

目前大部分浏览器使用的是这一个垃圾回收算法，或是在这个算法上的变形。这个算法以图的形式将所有的对象连接起来，就像算法名称所示，回收过程分为两个阶段：

1. 标记(Mark)：它首先假设存在一些根(root)节点（比如Javascript中的全局对象），从根节点出发，试图去访问其它的每一个与它相连的节点。在Javascript中，如果访问到的节点非基本数据类型(Primitive type)，也就是Object或者Array，则递归这一过程，所有被访问到的节点都被标记。
2. 清除(Sweep)：经过上面的步骤之后，那么那些存在但没有被标记的对象，则进行回收。

![Alt text](http://www.html5rocks.com/en/tutorials/memory/effectivemanagement/images/image03.png)

如果说Reference Counting的回收条件是“当某个对象不再被需要”，那么Mark-and-Sweep的回收条件则是“当某个对象不再能被访问”。

同时我们再回过头来看在前一个算法中会造成内存泄露的例子，很明显如果将算法换成Mark-and-Sweep，即使A与B互相引用，但是从根节点出发无法被访问，那么还是会对他们进行回收。


### V8

实际情况会比我们想象的复杂的多，比如V8引擎就一共使用了三种垃圾回收算法。

#### Two Generational Collector(分代收集算法)

分代收集算法实际只能算三色标记算法(Tri-color marking)的一种策略。该算法的依据是：最新被分配内存空间的对象通常活的时间都不会太长。这也被称作“弱代假说”(infant mortality or the generational hypothesis)。

这个算法将内存空间分为两代(generation)，年青一代(young generation)和老一代(old generation)。在年青一代区域内存的分配和回收频繁并且迅速，老一代的区域内存的分配缓慢并且次数较少。一个对象被划分为“年青”和“老”的依据是，它从出生到存活至今被分配的字节数。

V8引擎的最外层使用的是这个算法，但是在年青一代和老一代的内存空间中又有独立的垃圾回收算法。年青一代使用的是切尼算法(Cheney's algorithm)，而老一代使用的是标记压缩(Mark-compact)算法。

#### Cheney's algorithm(切尼算法)

切尼算法将堆(heap)分为相等的两个空间，分别命名为from和to，新增对象的内存空间分配是从名为to的那一部分开始的。当to空间的内存不够分配时，年青一代的GC便被触发。

首先GC会交换from和to，这样原来的to便成了from；然后from被扫描，所有“活着”的对象都面临着选择：是被复制到to空间还是被分配到老一代内存中。一般来说这样一个过程不会超过10毫秒。

我们可以继续看看切尼算法是如何把活着的对象都移动到新的to空间的。

假设我们已经将from和to空间互相交换过了，接下来需要做的如何找到“活着”的对象，并且将活着的对象转移到新的to空间上去：

- 算法依次扫描被栈(stack)引用的堆(heap) 上的对象（至于栈和堆的关系，这么解释可能不太严谨，你暂且可以这么以为：栈上存放的是执行过程中的变量名称，而变量名称所引用的对象，分配的内存空间则存放在堆上）：
    - 如果对象还没有被转移到新的to空间上，那么就在to空间创建一份拷贝，并且将当前from空间的该对象修改为一个指向to空间拷贝的指针。并更新栈上引用的指针，指向新的拷贝；
    - 如果对象已经被转移到了新的to空间上，那么把栈上指向from的指针改为指向to上的新拷贝即可
- 算法依次扫描已经转移到to上的对象，并且检查它们在from空间上的引用，重复上面的步骤

#### Mark-compact algorithm(标记压缩算法)

标记压缩算法是标记清除算法的一种变形，它主要解决的是标记清除之后内存空间空间碎片化不连续的问题。以基于图表(Table-based)的标记压缩算法为例：

- 标记与清除过程与Mark-and-sweep算法相同
- 压缩过程从堆的底部（低位）向头部（高位）进行，每当扫描到一个被标记的对象，将它转移至第一个可用低位。并且将当前的移动记录插入至表(break table)中，该记录包括重置的位置，以及重置位置与原位置的差别。表的位置就放在压缩的堆中，但是该位置对其他对象来说是未被使用的。
- 随着压缩的进行，












