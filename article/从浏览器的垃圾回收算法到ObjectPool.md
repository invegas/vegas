


浏览器的脚本引擎有一个不足的地方是，你无法通过javascript语法强制让脚本引擎进行垃圾回收（Garbage Collection，在文中以GC代替）和内存释放。虽然你在脚本中执行 `delete someVariable` 或者 `someVariable = null` 又或者 `someVariable = void 0`。但事实上你做的都只是删除了变量对某个对象的引用而已，至于被删除引用的对象是否能够被回收，又何时能否被回收，这就只能由脚本引擎说得算了。

这会留下一个性能上的隐患，因为GC也是要消耗浏览器资源的。理想的状态应该是在浏览器进程空闲的时候进行GC，相反如果GC不巧发生在很多脚本需要处理的时候，这会给我们的程序火上浇油，让我们的程序显得慢和卡——那么流畅的标准又是什么？至少应该满足每秒60帧(如果你有PC游戏经验的话，30fps的画面感也是可以接受的)。换而言之，你必须在16.7ms之内执行完每一帧的所有脚本。

这篇文章主要分为两部分，一是浏览器的脚本引擎的垃圾回收算法，二是如何使用Object Pool解决GC引起性能问题。

## 脚本引擎的垃圾回收算法

### Reference Counting

早在Javascript 1.1版本和Netscape 3中（甚至在早期火狐中），一个对象是否被回收是由这个对象的被引用次数决定的。对象一旦被创建并被一个变量引用，那么它的引用次数便是1，如果该对象又被赋值给了另一个变量，那么引用便增为2.一旦某变量删除了对该对象的引用或者另被赋值，那么该对象的引用便又降为1.理论上来说，当一个对象的被引用次数降为0时，表示没有任何变量在引用该对象了，它已经毫无用处可以被回收从内存中释放了。

但是这个算法有一个缺陷，比如当存在如下图循环引用的情况时：

```
A<-------|     C----->X
|        |     D----->Y
|------->B     E----->Z
```

A与B互相引用，A和B的被引用次数都不为0，按照算法规则是不会被垃圾回收。但实际情况是A与B成了座“孤岛”，没有任何以外的变量引用他们。他们不会被回收，又不会再被发现和引用，这便造成了内存泄露。

举个实际的例子，已知的在IE6、7中，DOM对象的回收使用的就是Reference Counting算法，比如下面这个例子

```
var div = document.createElement("div");
div.onclick = function handler(){
  doSomething();
};
```

- div通过onclick属性对函数handler存在引用
- 函数对div也存在引用，因为在handler的作用域中可以访问到div

这样的循环会导致两个对象都没有办法被垃圾回收，引起内存泄露。

### Mark-and-Sweep

这个算法以图的形式将所有的对象连接起来，就像算法名称说的那样，分为两个阶段：

1. 标记(Mark)：它首先假设存在一些根(root)节点（比如Javascript中的全局对象），从根节点出发，试图去访问其它的每一个与它相连的节点。在Javascript中，如果访问到的节点非基本数据类型(Primitive type)，也就是Object或者Array，则递归这一过程，所有被访问到的节点都被标记。
2. 清除(Sweep)：经过上面的步骤之后，那么那些存在但没有被标记的对象，则进行回收。

![Alt text](http://www.html5rocks.com/en/tutorials/memory/effectivemanagement/images/image03.png)

如果说Reference Counting的回收条件是“当某个对象不再被需要”，那么Mark-and-Sweep的回收条件则是“当某个对象不再能被访问”。

同时我们再回过头来看在前一个算法中会造成内存泄露的例子，很明显如果将算法换成Mark-and-Sweep，即使A与B互相引用，但是从根节点出发无法被访问，那么还是会对他们进行回收。




