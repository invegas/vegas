<!DOCTYPE html>
<html>
<head>
	<title>漫谈prototype</title>
	<link rel="stylesheet" type="text/css" href="css/bootstrap.css">
	<link rel="stylesheet" type="text/css" href="prettify/sunburst.css">
	<script type="text/javascript" src="prettify/prettify.js"></script>	
	<style type="text/css">
		body {
			font-family: '微软雅黑';
		}
		blockquote p{
			font-style: italic;
			font-size: 12px;
		}
	</style>
</head>
<body onload="prettyPrint()">
	<div class="container">
		<div class="row">
			<div class="span1"></div>
			<div class="span6">
				<h3>如何组织Html元素与如何进行CSS命名（上）</h3>
			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>		
		<div class="row">
			<div class="span1"></div>
			<div class="span6">



			<p>javasscript的prototype原型链一直是一个难点，这篇文章是对自己这段时期学习的一个总结，在这里不谈ECMAScript标准，也不会用UML图画出各种关系（结合这两方面谈的文章非常的多），只力求最浅显易懂，深入浅出，供以后自己和各位参考。</p>		
			<p>javascript的function一种对象(object)，他们有方法和属性，方法比如call/apply，而prototype则是function的一个属性。</p>
<pre>
	function和object到底是什么关系？function这种数据类型和其它的数据类型有什么区别？javascript有几种数据类型？
</pre>
			<p>一旦你定义了一个函数，它即自带了一个prototype属性</p>
<pre class="prettyprint lang-javascript">
function t() {};
typeof t.prototype // "object";
</pre>
			<p>你可能已经知道使用函数作为一个构造函数，来生产一系列对象。比如</p>
<pre class="prettyprint lang-javascript">
function Some(name, color) {
  this.name = name;
  this.color = color;
  this.method = function(){}
}

var a1 = new Some("Lee", "black"); //实例化一个对象
</pre>
			<p>上面的Some类的属性和方法也可以放在prototype对象中，比如</p>
<pre class="prettyprint lang-javascript">
function Some() {
}
Some.prototype.name = "Lee" //形式一
Some.prototype = { //形式二
	name: "lee",
	color: "black",
	method: function () {

	}
}

var a1 = new Some("Lee", "black"); //实例化一个对象
</pre>
			<p>虽然形式不同，但至少现在使用起来的效果是一致的。当你使用a.Lee或者a.method时，结果是一样的，现在还看不出分别</p>
			<br>
			<strong>Ok，那么第一点要注意的是，prototype是活着(live)的属性！</strong>
			<br>
<pre class="prettyprint lang-javascript">
function Some() {}
var a = new Some();
a.method // unfefined

Some.prototype.method = function () {
	console.log("hello");
}

a.method // function () {console.log("Hello")}
</pre>
			<p>上面的代码想说明的是，在生成实例a时，构造函数没有method方法，所以a也没有，可以理解；但是之后构造函数在prototype属性里又添加上去了，虽然是在a生成之后添加的，但是a仍然照样拥有，<strong>与构造函数添加的时间无关。</strong></p>

			<p>第二个问题来了，如果这个对象内部和prototype都定义了相同的字段怎么办，比如</p>
<pre class="prettyprint lang-javascript">
function Some() {
	this.color = "yellow";
}
Some.prototype.color = "black";

var a = new Some();
a.color //?
</pre>
			<p>上面的代码中，我在对象的内部和prototype上分别都定义了color，当我从实例中访问的时候，应该显示的是哪一个颜色？</p>
			<br>
			<p><strong>要注意的是第二点，javascript引擎首先会检查a的属性里有没有color，如果没有的话去它的构造函数的prototype(a.constructor.prototype)里有没有该属性</strong></p>
			<br>
			<p>让我们再看的远一点，任何一个对象都应该有自己的构造函数，函数的prototype属性也是个对象，那它的构造函数是什么？</p>
<pre class="prettyprint lang-javascript">
function Some() {
	this.color = "yellow";
}
var a = new Some();

a.constructor.prototype.constructor 
// function Some() {this.color = "yellow";}

a.constructor.prototype.constructor.prototype 
// Some {}
</pre>
			<p>上面的原型链可以无限的追溯下去，<strong>通过原型链，可以追溯到最终的构造函数<code>Object()</code></strong>，这也就解释了，为什么即使我们没有在函数上定义<code>toString()</code>函数，<code>a.toString()</code>的方法也是存在的，因为它最终调用的追溯到的Object的toString方法。</p>
			<p><strong>新的问题是，如何区分自己的property和原型链上的属性，并且你能保证所有的属性都是可以访问的吗？</strong></p>
			<p>众所周知，用<code>for...in</code>循环就可以解决这个问题</p>

			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>
	</div>
	<script type="text/javascript" src="js/bootstrap.js"></script>
</body>
</html>