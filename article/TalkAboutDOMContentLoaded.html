<!DOCTYPE html>
<html>
<head>
	<title>从onload和DOMContentLoaded谈起</title>
	<link rel="stylesheet" type="text/css" href="css/bootstrap.css">
	<link rel="stylesheet" type="text/css" href="prettify/sunburst.css">
	<script type="text/javascript" src="prettify/prettify.js"></script>	
	<style type="text/css">
		body {
			font-family: '微软雅黑';
		}
	</style>
</head>
<body onload="prettyPrint()">
	<div class="container">
		<div class="row">
			<div class="span1"></div>
			<div class="span6">
				<h3>从onload和DOMContentLoaded开始</h3>
			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>		
		<div class="row">
			<div class="span1"></div>
			<div class="span6">
				<p>当<code>onload</code>事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</p>
				<p>当<code>DOMContentLoaded</code>事件触发时，仅当DOM加载完成，不包括样式表，图片。</p>
				<p>我们需要给一些元素的事件绑定处理函数。但问题是，如果那个元素还没有加载到页面上，但是绑定已经执行完了，想当然这是没有效果的。这两个事件大致就是用来避免这样一种情况，将绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再执行需要的代码。</p>
				<p>更重要的是，DOMContentLoaded机制更加合理，因为我们可以容忍图片延迟加载，却不可以容忍看见内容后页面不可交互</p>
				<p>在没有出现DOMContentLoaded事件出现以前，许多类库中都有模拟这个事件的方法，比如jQuery中著名的<code>$(document).ready(function(){});</code>。稍后把各个类库中总结DOMcontentLoaded的方法整理一下</p>
				<br>
				<br>
				<p><strong>接下来看一些DOMContentLoaded的边界情况</strong></p>
				<p><strong>虽然文档称该事件仅当在DOM加载完成之后触发，实际上并非如此</strong></p>
				<p>在某些版本的Gecko和Webkit引擎的浏览器中，有些情况会使等待样式表加载完成后才触发DOMContentLoaded事件。最普遍的情况是<code>&lt;script src=""&gt;</code>跟在一个<code>&lt;link rel="stylesheet"&gt;</code>之后，无论这个script标签是在head还是在body中，只要跟在link的后面。比下面这个栗子</p>
				<p>Html: </p>
					<pre class="prettyprint lang-html">
&lt;!DOCTYPE html&gt;
&lt;head&gt;
&lt;link rel="stylesheet" href="stylesheet.css"&gt;
&lt;script src="script.js"&gt;&lt;/script&gt;
&lt;/head>
&lt;body>
&lt;div id="element"&gt;The element&lt;/div&gt;
&lt;/body&gt;</pre>
<p>stylesheet.css:</p>
<pre class="prettyprint lang-css">
#element { color: red; }
</pre>
<p>script.js</p>
<pre class="prettyprint lang-javascript">
document.addEventListener('DOMContentLoaded', function () {
	alert(getComputedStyle(document.getElementById('element'), null).color);
}, false);
</pre>
				<p>你可以尝试强制使服务器端使style延迟加载一段时间，测试的结果是，在某些版本的Firefox，Chrome，Safari中最后一段脚本是可以读出style的属性值，比如#FF0000或者rgb(255, 0, 0)，而这验证了我上面的说法，而在opera中却无法读出style的属性。</p>
				<p>把脚本外链把样式外链之后已经是一种通用的作法，甚至在jquery的官方文档中也是这样推荐的</p>
				<p>其实对大部分脚本来说，这样的脚本等待外链的机制还是有意义的，比如一些DOM和样式操作需要读取元素的位置，颜色等。这就需要样式先于脚本加载</p>
				<br>
				<br>
				<p><strong>加载样式表会阻塞外链脚本的执行</strong></p>
				<p>一些Gecko和Webkit引擎版本的浏览器，包括IE8在内，会同时发起多个Http请求来并行下在样式表和脚本。但<strong>脚本不会被执行，直到样式被加载完成。在未加载完之前甚至页面也不会被渲染。</strong>你可以在一些浏览器的开发工具中验证这个想法。</p>
				<p><strong>但是在opera中样式的加载不会阻塞脚本的执行。</strong>有一些类库中模拟dom ready的行为中会把这个“意外”修正为何Chrome他们类似。</p>

				<p>附带一句，在Explorer和Gecko中，样式的加载同样也会阻塞直接写在页面上的脚本的执行（脚本接在样式表中）。在Webkit和Opera中页面上的脚本会被立即执行。</p>


			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>
	</div>
	<script type="text/javascript" src="js/bootstrap.js"></script>
</body>
</html>