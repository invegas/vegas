<!DOCTYPE html>
<html>
<head>
	<title>Javascript的实例化与继承：请停止使用new关键字</title>
	<link rel="stylesheet" type="text/css" href="css/bootstrap.css">
	<link rel="stylesheet" type="text/css" href="prettify/sunburst.css">
	<script type="text/javascript" src="prettify/prettify.js"></script>	
	<style type="text/css">
		body {
			font-family: '微软雅黑';
		}
		blockquote p{
			font-style: italic;
			font-size: 12px;
		}
	</style>
</head>
<body onload="prettyPrint()">
	<div class="container">
		<div class="row">
			<div class="span1"></div>
			<div class="span6">
				<h3>Javascript的实例化与继承：请停止使用new关键字</h3>
			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>		
		<div class="row">
			<div class="span1"></div>
			<div class="span6">




			<p>标题当然是有一点耸人听闻了，但个人觉得使用new关键字确实并非是一个最佳的实践。换句话说，我觉得有更好的实践，让实例化和继承的工作在javascript更友好一些，本文所做的工作就是教你对new关联的操作进行一系列封装，甚至完全抛弃new关键字。</p>

            <p>在阅读本文之前你必须要对javascript中关于<strong>prototype</strong>, <strong>constructor</strong>, 以及如何实现面向对象，this关键字的使用等概念<strong>非常熟悉</strong>，否则，相信我，你会看的非常头大。如果目前还不是很熟悉的话，可以参考我的前两篇博客<a href="http://qingbob.com/blog/Javascript:%20%E4%BB%8Eprototype%E6%BC%AB%E8%B0%88%E5%88%B0%E7%BB%A7%E6%89%BF(1)" target="_blank">Javascript: 从prototype漫谈到继承(1)</a>，<a href="http://qingbob.com/blog/Javascript:%20%E4%BB%8Eprototype%E6%BC%AB%E8%B0%88%E5%88%B0%E7%BB%A7%E6%89%BF(2)" target="_blank">Javascript: 从prototype漫谈到继承(2)</a>。这两篇文章目前还有一些叙述有误的地方，但是还是可以提供一些参考。</p>
            <br>
            <h4>传统的实例化与继承</h4>
            <br>
            <p>还是先温习一下javascript继承的原理吧</p>
            <p>假设我们有两个类Class:<code>function Class() {}</code>和SubClass:<code>function SubClass() {}</code>，SubClass需要继承自Class，应该怎么做？</p>
            <ul>
                <li>首先，Class中被继承的属性和方法必须放在Class的prototype属性中</li>
                <li>再者，SubClass中自己的方法和属性也必须放在自己prototype属性中</li>
                <li><strong>别忘了SubClass的prototype也是一个对象，但这个对象的prototype(__proto__)指向的Class的prototype</strong></li>
                <li>这样以来，由于prototype链的一些特性，SubClass的实例便能追溯到Class的方法。这样便实现而来继承</li>
            </ul>
<pre class="prettyprint lang-javascript">
new SubClass()      Object.create(Class.prototype)
    |                    |
    V                    V
SubClass.prototype ---> { }
                        { }.__proto__ ---> Class.prototype
</pre>            
            <p>我们举的第一个例子，要做以下几件事:</p>
            <ul>
                <li>有一个父类叫做Human</li>
                <li>使一个名为Man的子类继承自Human</li>
                <li>子类继承父类的一切，并调用父类的构造函数</li>
                <li>实例化这个子类</li>
            </ul>
<pre class="prettyprint lang-javascript">
// 构造函数/基类
function Human(name) {
    this.name = name;
}

// 基类的方法保存在构造函数的prototype属性中
// 便于子类的继承
Human.prototype.say = function () {
    console.log("say");
}

// 道格拉斯的object方法
// 等同于Object.create
function object(o) {
    var F = function () {};
    F.prototype = o;
    return new F();
}

// 子类Man
function Man(name, age) {
    // 调用父类的构造函数
    Human.call(this, name);
    // 自己的属性age
    this.age = age;
}

// 继承父类的方法
Man.prototype = object(Human.prototype);
Man.prototype.constructor = Man;

// 实例化
var man = new Man("Lee", 22);
console.log(man);
</pre>
            <p>以上我们可以总结出传统的实例化与继承的几个特点:</p>
            <ul>
                <li>传统方法中的“类”<strong>一定</strong>是一个构造函数——你可能会问还有可能不是构造函数吗？当然可以，文章的最后会介绍如何实现一个不是构造函数的类。</li>
                <li>属性和方法的继承<strong>一定</strong>是通过prototype实现，也一定是通过<code>Object.create</code>方法，也就是道格拉斯的object方法。你可能又要问了：何以见得，Object.create与object方法是一致？这当然不是我说的，而是在MDN上object是作为Object.create的一个Polyfill方案。</li>
                <li>实例化一个对象，<strong>一定</strong>是通过<code>new</code>关键字来实现的。（你能回忆起除了new关键字，还有其他哪些方式来创建一个对象吗？）</li>
            </ul>
            <br>
            <p><strong>那么new关键字的不足之处在哪？</strong></p>
            <br>
            <p>首先在《Javascript语言精粹》(Javascript: The Good Parts)中，道格拉斯原话是这样叙述的:</p>
            <blockquote>
                <p>If you forget to include the new prefix when calling a constructor function, then this will not be bound to the new object. Sadly, this will be bound to the global object, so instead of augmenting your new object, you will be clobbering global variables. That is really bad. There is no compile warning, and there is no runtime warning. (page 49)</p>
            </blockquote>
            <p>大意是说在该使用new的时候忘了new关键字，将会非常糟糕。但我不觉得这是一个恰当的理由，或者说这个理由非常牵强。遗忘使用任何东西都会引起一系列的问题，何止于new关键字呢，再者说其实这个是有办法解决的：</p>
<pre class="prettyprint lang-javascript">
function foo()
{
   // if user accidentally omits the new keyword, this will 
   // silently correct the problem...
   if ( !(this instanceof foo) )
      return new foo();

   // constructor logic follows...
}</pre>
            <p>或者作为一个更通用的方案，抛出异常即可</p>
<pre class="prettyprint lang-javascript">
function foo()
{
    if ( !(this instanceof arguments.callee) ) 
       throw new Error("Constructor called as a function");
}</pre>
            <p>又或者按照John Resig的方案，我们准备一个<code>makeClass</code>工厂函数，把大部分的初始化功能放在一个init方法中，而非构造函数自己中：</p>
<pre class="prettyprint lang-javascript">
// makeClass - By John Resig (MIT Licensed)
function makeClass(){
  return function(args){
    if ( this instanceof arguments.callee ) {
      if ( typeof this.init == "function" )
        this.init.apply( this, args.callee ? args : arguments );
    } else
      return new arguments.callee( arguments );
  };
}</pre>            
            <p>我认为new关键字不是一个好的实践的原因是因为，</p>
            <blockquote>
                <p>new is a remnant of the days where JavaScript accepted a Java like syntax for gaining “popularity”.</p>
            </blockquote>
            <blockquote>
                <p>And we were pushing it as a little brother to Java, as a complementary language like Visual Basic was to C++ in Microsoft’s language families at the time.</p>
            </blockquote>
            <p>和道格拉斯说的：</p>
            <blockquote>
                <p>This indirection was intended to make the language seem more familiar to classically trained programmers, but failed to do that, as we can see from the very low opinion Java programmers have of JavaScript. JavaScript’s constructor pattern did not appeal to the classical crowd. It also obscured JavaScript’s true prototypal nature. As a result, there are very few programmers who know how to use the language effectively.</p>
            </blockquote>         
            <p>简单来说，javascript是一种prototypal类型语言，在创建之初，为了迎合市场的需要，为了让人们觉得它和Java是类似的，才引入了new关键字。<strong>Javascript本应通过它的Prototypical特性来实现实例化和继承，但new关键字让它变得不伦不类。</strong>想了解上面引用段落的全篇，可以参考本文最后的参考文献。</p>               
            <br>
            <h4>把传统方法加以改造</h4>
            <br>
            <p>我们目前有两种选择，一是完全抛弃new关键字，二是把含有new关键字的操作封装起来，只向外提供友好的接口。现在我们先做第二件事，最后来做第一件事。</p>
            <p>那么封装的接口是什么？：</p>
            <ul>
                <li>所有的类都派生自我们自己的一个基类<code>Class</code></li>
                <li>派生出一个子类方法：<code>Class.extend</code></li>
                <li>实例化一个类方法：<code>Class.create</code></li>
            </ul>
            <p>开始吧，先把结构搭起来：</p>
<pre class="prettyprint lang-javascript">
// 基类
function Class() {}

Class.prototype.extend = function () {};
Class.prototype.create = function () {};

Class.extend = function (props) {
    return this.prototype.extend.call(this, props);
}
</pre>
            <p>因为所有的类都能派生子类都能实例化，加上所有的类都派生自基类Class，所以我们把最关键的<code>extend</code>和<code>create</code>方法放在Class的prototype中</p>
            <p>接下来实现create和extend方法，解释就写在注释中了：</p>
<pre class="prettyprint lang-javascript">
Class.prototype.create = function (props) {
    /*
        正如开始所说，create实际上是对new的封装
        create返回的实例实际上是new出来的实例
        this即指向调用当前create的子类构造函数
    */
    var instance = new this();
    /*
        将传入的参数作为该实例的“私有”属性
        更准确应该说是“实例属性”，因为并非私有
        而是这个实例独有
    */
    for (var name in props) {
        instance[name] = props[name];
    }
    return instance;
}

Class.prototype.extend = function (props) {
    /*
        派生出来的新的子类
    */
    var SubClass = function () {};
    /*
        继承父类的属性，
        当然前提是父类的属性都放在prototype中
        而非上面的“实例属性”中
    */
    SubClass.prototype = object(this.prototype);
    for (var name in props) {
        SubClass.prototype[name] = props[name];
    }
    SubClass.prototype.constructor = SubClass;

    /*
        因为需要以SubClass.extend的方式调用
        所以要重新赋值
    */
    SubClass.extend = SubClass.prototype.extend;
    SubClass.create = SubClass.prototype.create;

    return SubClass;
}
</pre>
            <p>那么如何使用，如何对它进行测试呢，还是哪我们上面的Human和Man的例子：</p>
<pre class="prettyprint lang-javascript">
var Human = Class.extend({
    say: function () {
        console.log("Hello");
    }
});

console.log(Human.create());

var Man = Human.extend({
    walk: function () {
        console.log("walk");
    }
})


console.log(Man.create({
    name: "Lee",
    age: 22
}));

</pre>













			</div>
			<div class="span4"></div>
			<div class="span1"></div>
		</div>
	</div>
	<script type="text/javascript" src="js/bootstrap.js"></script>
</body>
</html>